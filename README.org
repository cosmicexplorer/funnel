#+TITLE: funnel
#+TAGS: [ enablinganyone : workingwithothers avoidingpitfalls codingbyyourself batteriesincluded ]
#+TAGS: [ stateoftheart : makingionatural leaningonpowerfultools performance tracing typesafety ]
#+TAGS: [ makingionatural : usingdistributedmemory avoidingpitfalls ]
#+TAGS: [ avoidingpitfalls : variablescurrentlyarebad ]
#+TAGS: [ canonicalsolutionstohardproblems : batteriesincluded ]
#+TAGS: [ makingionatural : canonicalsolutionstohardproblems ]
#+TAGS: [ tracing : trackingdistributedmemory streamingbuffercontrol makingioaneffect ]
#+TAGS: [ virtualization : filesystem processexecution usingdistributedmemory ]
#+TAGS: [ performance : virtualization ]
#+TAGS: [ typesafety : shellcompletionscripts parsehelptext canonicalsolutionstohardproblems ]

#+TODO: UNCLEAR RESEARCH PLAUSIBLE PROOFOFCONCEPT FEASIBLE MAINTAINABLE | TODO DONE

* RESEARCH Overview [0%]

The idea behind the name "funnel" is that it should allow writing code at a higher level of abstraction, which all gets compiled down to the lowest common denominator of bash scripting.

This currently has a few separate angles:
1. [ ] [[#ASpecificLanguage][An effect-based type system which is trained upon ~--help~ output and/or shell completion scripts.]]
   - [ ] for easier expression of parallelism through laziness.
   - [ ] for [[statically-known][/much/ stronger typing guarantees]] than are available in other languages that don't have such fine understanding of I/O.
2. [ ] [[#VirtualEnvironment][A virtualized filesystem and process execution environment.]]
   - [ ] to convert the knowledge of that type system directly into unheard-of performance.
   - [ ] to [[*Toolchain Bootstrapping][canonicalize incredibly well-documented /(read: well-typed!)/ shell tooling]].
   - [ ] ...and [[dropping-in][this should all "just work" on everyone's existing code]] without too many changes!
3. [ ] [[#RechargableBatteriesIncluded][An extremely natural method to /avoid the "multi-language problem" entirely,/ **using the shell as the universal interface.**]]
   - [ ] very strongly influenced by [[#Ammonition][the way the Ammonite REPL converts filesystem and process actions into structured results]] that can be /manipulated with a few implicits/.
   - [ ] /most/ importantly, [[dynamic-io-control][I/O /must/ not be arbitrarily buffered by the programming language]]. **Ideas of input and output of processes should be thrown in the gutter.**

* Argument for a Much More Virtual Environment    :trackingdistributedmemory:
  :PROPERTIES:
  :CUSTOM_ID: VirtualEnvironment
  :END:

1. Building on ~upc~, consider how performance analysis and benchmarking can change overnight if/when it's not only possible to /trace/ filesystem and network I/O vs RAM pressure vs CPU, but to *directly /orchestrate/ it*.
  - In particular, the [[https://github.com/pantsbuild/pants][pants]] project is developing a method for invoking arbitrary subprocesses (typically compilers/etc) within a virtual filesystem with [[https://github.com/pantsbuild/pants/tree/master/src/rust/engine/fs/brfs][~brfs~]].
2. Consider the expected/proposed/conjectured utility of a generic process execution engine in [[https://github.com/cosmicexplorer/upc][~upc~]].
  - ~upc~ was built on top of years of work to extract the process execution itself from the rest of the build tool, which has resulted in the fantastic [[https://github.com/pantsbuild/pants/blob/master/src/rust/engine/process_executor/src/main.rs][~process_executor~]] debugging tool.

** MAINTAINABLE Cacheable, Serializable Process Executions :processexecution:
    :PROPERTIES:
    :CUSTOM_ID: CacheableExecutions
    :END:

Pants, bazel, and other projects have been continuously collaborating on an [[https://github.com/bazelbuild/remote-apis][extensible shared format for specifying a process execution request]]. This is used in pants and bazel today to execute processes that create files for build tasks. As a testament to its reproducibility, multiple organizations rely on this API to homogenously execute the same processes remotely, or to pull down a cached result of the same process execution (e.g. with a backend like [[https://github.com/twitter/scoot][Scoot]].


** PLAUSIBLE Breaking the Speed of Light by Being Omniscient                                        :filesystem:usingdistributedmemory:
   :PROPERTIES:
   :CUSTOM_ID: SpeedOfLight
   :END:

A virtual file system using FUSE doesn't incur too much overhead on Linux /[citation needed]/. However, a filesystem, by construction, can only use heuristics to optimize its performance (and that "performance" has /many/ axes). *What if we could know /~exactly/ which files were about to be read/written at all times?*

- If we knew every file that was going to be written by a process beforehand, we could allocate self-growing buffers for each of those paths, avoiding the need to allocate any resources in real time.
  - If we knew the expected /size/ of those future files, we could allocate the appropriate regions immediately.
- If we knew every file that needed to be /read/ by a process beforehand, we could allocate (perhaps even pool) read-only buffers before the process executes.

<> fast enough IPC is just an FFI
<<> eugene and zinc vfs
https://eed3si9n.com/cached-compilation-for-sbt
*If this omniscience was achievable, we could expect our processes to run "faster than the speed of light", i.e. faster than any conceivable heuristic model.*

*** RESEARCH Type Safety and Performance by Omniscience [0%] :shellcompletionscripts:parsehelptext:
     :PROPERTIES:
     :CUSTOM_ID: TypeSafetyFromHelpText
     :END:

Parsing bash/zsh completion scripts (or obtaining them from e.g. ~--help~) should accomplish two goals:
1. [ ] We can validate the types of arguments /before/ running the script at all.
   - [ ] This should improve type safety automatically, in a way that can be run on the script /before executing it at all/.
     - [ ] can shellcheck do this already?
   - [ ] It should be relatively easy to write "stubs" [[https://mypy.readthedocs.io/en/stable/stubs.html][(like mypy)]] which can fill in the blanks for hand-written scripts. <<mypy-stubs>>
   - [ ] This would be an extremely natural place to start eventually developing a more thorough type inference system for shell scripts in general!
2. [ ] We should be able to produce, from such bash/zsh completion scripts, a form of these idempotent bazel remexec API-compatible ~Process~ execution requests, and *very* performantly execute them against a VFS.

/Benefits:/
- This capitalizes on the existing utility of ~process_executor~, with a natural shell syntax.
- This allows arbitrary other tools to very performantly execute processes /against/ a remote backend, or /as/ a remote backend due to the improved performance thanks to the VFS.
- This should expose a ~upc~-like API in which processes can transparently share memory blobs and directory structures locally or remotely.
  - *This could be the FFI to end all FFIs.*

** PLAUSIBLE Subsume ~learning-progress-bar~         :streamingbuffercontrol:

- While this project focuses on making process executions *type-safe, cacheable, and extremely fast* (<<statically-known>>), the [[https:github.com/cosmicexplorer/learning-progress-bar][~learning-progress-bar~]] project is more focused on *tracing what happens /during/ an execution* <<dynamic-io-control>>.
- *Both* projects:
  - focus on "dropping in" to existing command-line invocations and tooling people have already set up (<<dropping-in>>),
  - are intended to plug into a build tool.
- *Output streaming can be safely delegated to ~learning-progress-bar~, while this one focuses much more on one-shot executions.*

/I don't think anyone at all has been thinking about [[dynamic-io-control]] yet./ *!!*

*** Motivating Example: the [[https:github.com/undercasetype/Fraunces][Fraunces]] open-source [[https://v-fonts.com/][variable font]] :codingbyyourself:parsehelptext:variablescurrentlyarebad:
[[https://github.com/cosmicexplorer/Fraunces/blob/56a435d9ddd4ea6e627b282fb6e4c7b8a6f8f561/sources/build.sh#L28-L71][See this highly commented code from my attempt to fix the larger issues with the build system for the /Fraunces/ family of open-source variable fonts.]]

#+NAME: asdf
#+BEGIN_SRC sh :results silent :exports code :dir ~/font-sources/Fraunces/
#!/bin/sh
set -euxo pipefail

# Ensure this script is executed from within its own directory.
GIT_ROOT="$(git rev-parse --show-toplevel)"
cd "${GIT_ROOT}/sources"

# Only use this when necessary, are currently not all instances are defined in the VF designspace
# files.  generate static designspace referencing csv and variable designspace file later, this
# might not be done dynamically
# python ../mastering/scripts/generate_static_fonts_designspace.py


## Statics
static_fonts=(
  # 3 arguments per line.
  Roman/Fraunces_static.designspace ttf ../fonts/static/ttf
  Roman/Fraunces_static.designspace otf ../fonts/static/otf/
  Italic/FrauncesItalic_static.designspace ttf ../fonts/static/ttf/
  Italic/FrauncesItalic_static.designspace otf ../fonts/static/otf/
)
function get_static_instances_from_designspaces {
  ./extract_instances.sh {Roman,Italic}/*_static.designspace
}


# FIXME: This is a REALLY FANTASTIC CASE where shell scripting is EXCEEDINGLY difficult to work
# with, but JUST AS BAD AS THE PYTHON CODE IN fixNameTable.py and friends!!!! This is a *use case*!!
# NB: Especially take note of:
# (1) The hacky progress bar
# (2) The `stdbuf` unbuffering
# (3) The partial output redirection!
# (4) Being unable to use `xargs` or `parallel` with shell functions means recreating these
#     ".../*_static.designspace" globs in get_static_instances_from_designspaces()!

# NB: Looking to address all of the above with https://github.com/cosmicexplorer/funnel

function generate_static_fonts {
  # This is really quick to calculate, and lets us know how much progress we're making!
  total_num_static_instances="$(get_static_instances_from_designspaces | wc -l)"
  echo "Generating Static fonts ($total_num_static_instances in total)"

  # (1) Process each .designspace XML file and output format in parallel with `xargs`.
  # (2) At this point, we're dealing with a ton of output, so we tee it to stderr so the user can
  #     redirect to /dev/null if they don't need that finer-grained info.
  # (3) However on stdout, we filter for messages that describe successfully writing out a .otf or
  #     .ttf file, and give a quick progress bar with percentage, since we know how *many* instances
  #     we'll eventually need to write, even if we're not checking which exact ones those are.
  instances_processed=0
  printf '%s\n' "${static_fonts[@]}" \
    | 2>&1 stdbuf -i0 -o0 -e0 xargs -t -L 3 --max-procs=0 ./generate_font_instances.sh \
    | stdbuf -i0 -o0 -eL tee /dev/stderr \
    | sed -Ene 's#^INFO:fontmake.font_project:Saving (.*)$#\1#gp' \
    | while read just_saved_font; do
    instances_processed="$(($instances_processed + 1))"
    percent_complete="$((($instances_processed / $total_num_static_instances) / 100.0))"
    echo "${percent_complete}% complete: ${instances_processed}/${total_num_static_instances} (${just_saved_font})"
  done
}

time generate_static_fonts
exit 0

echo "Post processing"

gftools fix-dsig -a ../fonts/static/ttf/*.ttf
gftools fix-hinting ../fonts/static/ttf/*.ttf
# NB: This script appears to be doing something incredibly complex that it absolutely should not be
# attempting to do on its own.
python ../mastering/scripts/fixNameTable.py ../fonts/static/ttf/*.ttf
#+END_SRC

To really underline why there's such a searing need here, the build system isn't even attempting to do anything /too/ difficult with the font variability itself! It's simply trying to convert its design into something that works canonically with existing font file formats! And the tools are there -- **but not in a way that lets just anyone go off and start preparing their own font!!!**

**** What Does This Enable?                                :codingbyyourself:

Beatriz Lozano was able to create [[https://beatrizl.com/project/ancho][the beautiful and extremely unconventional Ancho font]]. Regardless of the thoughts about sheer runtime performance above, I want more fonts like this one.


* Motivation for Changes to the Language Itself
  :PROPERTIES:
  :CUSTOM_ID: ASpecificLanguage
  :END:

/A transpiler, standard library, and self-bootstrapping tool environment to write more portable and maintainable bash scripts./

The project owes immense inspiration to [[https://coffeescript.org][CoffeeScript]], which demonstrated it was possible to write more-complex code with an extended feature set and still work in all browser environments through transpilation, which then inspired the incorporation of those exact features into JavaScript at large.

** RESEARCH Bash Splintering                              :workingwithothers:

It seems very unfortunate that "bash" is likely still synonymous with "shell" for many people, only ebecause bash has also splintered in versions and feature sets across environments, and a lot of this may be due to the fact that [[https://apple.stackexchange.com/a/197172][macOS won't update its preinstalled version of bash to 4 or higher, due to concerns about the GPLv3 license used for bash 4]]. This means users writing bash often have to manually write lowest-common-denominator bash scripts (scripts which work on the lowest bash version they need to support) to ensure portability, which tends to make these scripts more difficult to write and maintain.

** PLAUSIBLE Toolchain Bootstrapping     :avoidingpitfalls:workingwithothers:

The more obvious error and detriment to portable bash scripting is simply not having the desired tools. For tools that users may have installed by default, there are still e.g. incompatibilities for macOS again (such as ~sed~ not accepting the ~-r~ flag). In general, though, versions of many shell tools may also be splintered across Linux distributions, depending on how often distributions update their toolchains and how often users upgrade their OS. This can lead to a tradeoff that developers make between maintaining a complete toolchain on all shell environments, and writing lowest-common-denominator bash again, without being able to use tools such as ~sed~ or ~grep~ as expected.

** PLAUSIBLE Avoiding Bash Pitfalls                        :avoidingpitfalls:

Separate from toolchains, many bash semantics can tend to confuse users, even experienced ones. Last week I learned that ~set -e~ doesn't exit on a failed command if it's within the body of a ~function~! Many other shells such as [[https://zsh.sourceforge.net][zsh]] fix issues with e.g. variable declarations, but those other shells are even less likely to be installed by default. [[https://www.shellcheck.net][ShellCheck]] is often used in codebases to avoid these pitfalls, but custom checks may still have to be written -- the [[https://pantsbuild.org][pants]] repo required this separate [[https://github.com/pantsbuild/pants/blob/4a19087e42ff05608a997b3b5f372420eaaeeb33/build-support/bin/check_shell.sh#L2][check for broken ~readonly~ statements which don't cause ~set -e~ to fail]]. This checking requires effort to maintain and still may be incomplete.

While ShellCheck *can* capture pitfalls and style errors, it seems that the number of pitfalls is so great that we might consider looking at a whitelisting approach instead -- not allowing these pitfalls to be expressable at all, perhaps by writing a new language, which transpiles to lowest-common-denominator bash scripts!

** RESEARCH Extending the Language         :canonicalsolutionstohardproblems:

One thing that transpilation also allows you to do is insert an arbitrary amount of code before and/or after the compiled script itself. [[https://coffeescript.org][CoffeeScript]], for example, will monkey-patch some array prototype methods before executing the script, to ensure that its compiled output will be able to rely on those array methods (see [[#prelude-runtime][Prelude / Runtime]]). In our case, we can consider adding to that prelude a layer which ensures up-to-date versions of not just *familiar* tools like ~sed~ and ~grep~, but also *extremely useful and portable tools* such as [[https://www.gnu.org/software/parallel][gnu parallel]] (which isn't very well-known, possibly due to not being installed by default (unlike ~xargs~, which is less featureful but does some of the same things)).

These portable tools can be said to provide an /unmatched/ level of /type safety/ as a result of their /mainenance over decades/. We should be able to /canonicalize/ and have the /compiler/ tell the user all of this, instead of leaving it as tribal knowledge. One of the most immediate ways to do this is to [[#TypeSafetyFromHelpText][infer a real form of type safety from the help text and/or shell completions]].

Also of note is that the CoffeeScript compiler will wrap the output in an anonymous function to ensure it won't pollute the global JavaScript namespace. Analogously, we can also consider introducing a better module system to bash, and perhaps a package manager (?).

* RESEARCH Goals       :workingwithothers:avoidingpitfalls:batteriesincluded:
Provide a shell scripting interface which:
- [ ] transpiles to highly portable bash.
- [ ] ensures modern shell builtins such as ~readarray~ can be invoked, using polyfills if necessary.
- [ ] self-bootstraps toolchains including reliable versions of command-line programs such as ~sed~ and ~parallel~.
  - [ ] creates self-bootstrapping executables!!!
- [ ] exposes new primitives which increase the power of the language to further reduce erroneous patterns (such as ~set -e~ not exiting within a ~function~).
- [ ] introduces a module system and package manager (?).
- [ ] is powerful enough to bootstrap the compiler
  - [ ] i.e. can it make writing a parser not awful?
- [ ] empowers people with existing experience in some shell environment

** Non-Goals
These shouldn't be considered right now:
1. worrying about compatibility with older bash versions.

** RESEARCH A Toolchain to Parallel the Python Stdlib     :batteriesincluded:
   :PROPERTIES:
   :CUSTOM_ID: RechargableBatteriesIncluded
   :END:

*** PROOFOFCONCEPT Becoming Ammonite                        :makingionatural:
    :PROPERTIES:
    :CUSTOM_ID: Ammonition
    :END:

Consider the extremely thoughtful and natural API of the [[https://ammonite.io/#Ammonite-REPL][ammonite REPL]].
  - Unlike other shell-like environments, Ammonite has the type safety and well-documented standard library of Scala built-in.

*** UNCLEAR Becoming Ourselves                       :leaningonpowerfultools:
Right now, the "funnel" language's functionality will be exposed through a single executable ~fun~.
- [ ] define command-line tools to control (such as ~sed~, ~parallel~, ~jq~, ~xmlstarlet~), and create a method to download them on all supported platforms.
- [ ] define "all supported platforms".
- [ ] define a grammar (see the [[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html][bash grammar]]).
- [ ] implement the transpiler.
  - [ ] figure out whether/how this language can be smart enough to bootstrap itself (i.e. the compiler is written in it)
    - *^!!!^*
  - [ ] begin to consider a module and package system for (portable) bash scripts
    - [ ] want something that will work on existing bash/zsh code (e.g. if you put them in a special
      directory they can be specially required or loaded)?
      - the [[#prelude-runtime]["Prelude"/"Runtime"]] for this (the shell script code that it loads)
        should have a function that is available to bash and zsh scripts that it loads which allows
        them to load something from the module system with similar ease!
- [ ] consider using any relevant parts of [[https://github.com/koalaman/shellcheck][shellcheck]]!!

* UNCLEAR Open Questions
** UNCLEAR GNU / BSD options             :workingwithothers:avoidingpitfalls:
Whether to accept command lines using GNU-style (probably long) options, or BSD options (with
different names and some missing functionality).
** UNCLEAR bash / zsh output                              :workingwithothers:
vWhether to generate code for bash or for zsh. **The output of this compiler should be 100%
compatible with code written for the output shell.**

** UNCLEAR Code Generation                 :makingionatural:codingbyyourself:
*** Prelude / Runtime
    :PROPERTIES:
    :CUSTOM_ID: prelude-runtime
    :END:

The output of a compile should have some "prelude" or "runtime" which is some script to be evaluated
containing e.g. convenience methods.

* License

GPL v3 (or any later version)]]
